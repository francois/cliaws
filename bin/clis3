#!/usr/bin/env ruby
#
#  Created on 2008-4-12.
#  Copyright (c) 2008. All rights reserved.

begin
  require 'rubygems'
rescue LoadError
  # no rubygems to load, so we fail silently
end

require "main"

$:.unshift File.dirname(__FILE__) + "/../lib"
require "cliaws"

Main {
  mixin :s3_object do
    argument("s3_object") do
      required
      argument_required
    end
  end

  mode("url") do
    mixin :s3_object

    def run
      puts Cliaws.s3.url(params["s3_object"].value)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("list") do
    mixin :s3_object

    def run
      puts Cliaws.s3.list(params["s3_object"].value)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("touch") do
    mixin :s3_object

    def run
      Cliaws.s3.put("", params["s3_object"].value)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("put") do
    argument("files_or_s3_path") do
      optional
      argument_required
      arity -2
    end

    option("data") do
      optional
      argument_required
    end

    def run
      paths = params["files_or_s3_path"].values
      s3_object = paths.pop

      single_put_mapper = lambda do |source, s3_path|
        raise ArgumentError, "Writing directly from STDIN is forbidden when STDIN's size is unknown.  The RightAws library will write a zero-byte file to Amazon's servers." unless source.respond_to?(:lstat) || source.respond_to?(:size)
        s3_path
      end

      multi_put_mapper  = lambda do |source, s3_path|
        if source.respond_to?(:path) then
          File.join(s3_path, File.basename(source.path))
        else
          raise ArgumentError, "Cannot write to a directory when one or more sources are not files: #{source.inspect}"
        end
      end

      if params["data"].given? && !paths.empty? then
        raise ArgumentError, "Cannot specify both --data and filename(s) to send."
      elsif params["data"].given? then
        sources = [StringIO.new(params["data"].value)]
        mapper  = single_put_mapper
      elsif paths == ["-"] then
        sources = [STDIN]
        mapper  = single_put_mapper
      else
        targets = paths.map {|filename| filename.to_s}
        case targets.length
        when 0
          sources = [STDIN]
          mapper  = single_put_mapper
        when 1
          sources = targets.map {|target| File.open(target, "rb")}
          mapper  = single_put_mapper
        else
          sources = targets.map {|target| File.open(target, "rb")}
          mapper  = multi_put_mapper
        end
      end

      sources.each do |source|
        target = mapper.call(source, s3_object)
        if source.respond_to?(:path) then
          puts "#{source.path} => #{target}"
        else
          puts "STDIN => #{target}"
        end

        Cliaws.s3.put(source, target)
      end
      exit_success!

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("rm") do
    mixin :s3_object

    def run
      Cliaws.s3.rm(params["s3_object"].value)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("cat") do
    mixin :s3_object

    def run
      Cliaws.s3.get(params["s3_object"].value, STDOUT)
      puts

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("get") do
    mixin :s3_object

    argument("local_file") do
      argument_required
      optional
    end

    def run
      if params["local_file"].given? then
        dest = File.open(params["local_file"].value, "wb")
      else
        dest = STDOUT
      end

      Cliaws.s3.get(params["s3_object"].value, dest)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  mode("head") do
    mixin :s3_object

    def run
      Cliaws.s3.head(params["s3_object"].value)

    rescue Cliaws::S3::UnknownBucket
      abort "Could not find bucket named #{$!.bucket_name}"
    end
  end

  def run
    abort "Required action argument missing.  Run '#{$0} help' for details."
  end
}
